<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>StatsBiboroku - Optimization</title><link href="https://ktrmnm.github.io/biboroku/" rel="alternate"></link><link href="https://ktrmnm.github.io/biboroku/feeds/optimization.atom.xml" rel="self"></link><id>https://ktrmnm.github.io/biboroku/</id><updated>2017-03-25T00:00:00+09:00</updated><entry><title>A combinatorial algorithm for minimizing symmetric submodular functions</title><link href="https://ktrmnm.github.io/biboroku/a-combinatorial-algorithm-for-minimizing-symmetric-submodular-functions.html" rel="alternate"></link><published>2017-03-25T00:00:00+09:00</published><updated>2017-03-25T00:00:00+09:00</updated><author><name>Kentaro Minami</name></author><id>tag:ktrmnm.github.io,2017-03-25:/biboroku/a-combinatorial-algorithm-for-minimizing-symmetric-submodular-functions.html</id><summary type="html">&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;対称劣モジュラ関数最小化の $O(|V|^3)$ アルゴリズムを与えた論文．ただし，対称劣モジュラ関数というのは，劣モジュラ関数 $f: 2^V \to \mathbb{R}$ であって，$f(X) = f(V - X)$ が成り立つものである．&lt;/p&gt;
&lt;h2&gt;文献情報&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Author: M. Queyranne&lt;/li&gt;
&lt;li&gt;Conference: SODA&lt;/li&gt;
&lt;li&gt;Year: 1995&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dl.acm.org/citation.cfm?id=313669"&gt;URL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コメント&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;対称劣モジュラ関数のわかりやすい例は，無向グラフのカット関数である．また，fが劣モジュラ関数のとき，$g(X) = f(X) + f(V - X)$ によって対称劣モジュラ関数 $g$ を作れる．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;「対称劣モジュラ関数最小化」とは，正確には，$|V …&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;対称劣モジュラ関数最小化の $O(|V|^3)$ アルゴリズムを与えた論文．ただし，対称劣モジュラ関数というのは，劣モジュラ関数 $f: 2^V \to \mathbb{R}$ であって，$f(X) = f(V - X)$ が成り立つものである．&lt;/p&gt;
&lt;h2&gt;文献情報&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Author: M. Queyranne&lt;/li&gt;
&lt;li&gt;Conference: SODA&lt;/li&gt;
&lt;li&gt;Year: 1995&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dl.acm.org/citation.cfm?id=313669"&gt;URL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コメント&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;対称劣モジュラ関数のわかりやすい例は，無向グラフのカット関数である．また，fが劣モジュラ関数のとき，$g(X) = f(X) + f(V - X)$ によって対称劣モジュラ関数 $g$ を作れる．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;「対称劣モジュラ関数最小化」とは，正確には，$|V| \geq 2$ として，空集合と全体集合を除いた $V$ の真部分集合の中で $f$ を最小化するものを求める問題である．例えば，非負重みをもつ無向グラフのカット関数の最小値は明らかに $f(\emptyset) = f(V) = 0$ であるが，そうではなくて非自明な部分の最小値を求める．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;アルゴリズムの概要は次の通りである： まず，任意の対称劣モジュラ関数に対して，pendent pairと呼ばれる頂点のペア $(s,t)$ が存在することが知られている．ここでpendent pairというのは，$s$ を固定したとき，s-tカットの最小値が1点集合 ${ t }$ によって達成されるもののことである．このようなペアは $O(n^2)$ 回の関数呼び出しで発見することができる．Queyranneのアルゴリズムは，pendent pair発見アルゴリズムを再帰的に $n-1$ 回呼び出すことで得られる．定義から，pendent pair $(s, t)$ があるとき，最小化問題の解 $X$ は $f(X) = f(t)$ であるか，$s, t \in X$ であるかのどちらかである．前者であれば終了だが，それは判定できないので，ひとまず $t$ と $f(t)$ の値を記憶しておく．後者であると仮定すると，$(s, t)$ をまとめて1頂点だと思うことで，サイズが $n-1$ の問題に帰着される．よって，「pendent pairを見つけて結合する」という操作を残り2頂点になるまで繰り返せば，記憶した $t$ のうちどれかがminimizerになっている．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;もともと，Nagamochi and Ibaraki (1992)の最小s-tカットアルゴリズムというものがあり，その拡張として提案されたらしい．&lt;a href="https://www.elsevier.com/books/submodular-functions-and-optimization/fujishige/978-0-444-52086-9"&gt;Fujishige (2005)&lt;/a&gt; のsection 13にも歴史が載っている．&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="[SODA]"></category><category term="離散最適化"></category><category term="劣モジュラ最小化"></category></entry></feed>